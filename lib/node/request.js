/*!
 * Hyperion - Request
 * Copyright(c) 2012 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */

/*!
 * External module dependencies
 */

var http = require('http')
  , mime = require('mime')
  , uuid = require('pauli').uuid;

/*!
 * Internal module dependencies
 */

var util = require('./util');

/*!
 * Extending http.IncomingMessage.prototype
 */

var req = exports = module.exports = {
  __proto__: http.IncomingMessage.prototype
};

/**
 * ### .id
 *
 * A unique id that is provided or generated for
 * a given request. Can either be generated by the
 * client and sent in as `header['x-request-id']`
 * or a uuid V4 will be generated as needed.
 *
 * // TODO: use uuid V1 (time based)
 *
 * @returns {String} request id
 * @name id
 * @api public
 */

Object.defineProperty(req, 'id',
  { get: function () {
      if (this._id) return this._id;
      this._id = this.headers['x-request-id'] || uuid();
      return this._id;
    }
});

/**
 * ### .accepted
 *
 * View the parsed list of acceptabled response types.
 *
 * @returns {Array} Accept header parsed
 * @name accepted
 * @api public
 */

Object.defineProperty(req, 'accepted',
  { get: function () {
      return this.headers && this.headers.accept
        ? util.parseAccept(this.headers.accept)
        : [];
    }
});

/**
 * ### .accepts (type)
 *
 * Determine if a specific type is acceptable as a
 * response type.
 *
 * TODO: support for multiple possible solutions (by quality)
 *
 * @param {String} type
 * @returns {Boolean} acceptable
 * @name accepts
 * @api public
 */

req.accepts = function (type) {
  var accept = this.accepted
    , match = false;

  if (!~type.indexOf('/')) {
    type = mime.lookup(type);
  }

  type = type.split('/');

  for (var i = 0; i < accept.length; i++) {
    var line = accept[i];
    if ((line.type === type[0] || line.type === '*')
    && (line.subtype === type[1] || line.subtype === '*')) {
      match = true;
    }
  }

  return match;
};
